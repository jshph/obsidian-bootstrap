#!/usr/bin/env bun
import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import {
  CallToolRequestSchema,
  ListPromptsRequestSchema,
  GetPromptRequestSchema,
  ListToolsRequestSchema,
  PromptArgument,
  PromptMessage,
  TextContent,
  Tool,
} from "@modelcontextprotocol/sdk/types.js";
import { z } from "zod";
import * as fs from "fs/promises";
import * as path from "path";
import { existsSync } from "fs";
import * as os from "os";
import { fileURLToPath } from 'url';
import { dirname } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Helper to find template directory
function findTemplatesRoot(): string {
  // Check common locations for templates
  const possiblePaths = [
    // Development: templates are in project root
    path.join(__dirname, '..', 'templates'),
    // Built executable: templates might be in same directory as executable
    path.join(process.cwd(), 'templates'),
    // Built executable: templates might be next to the executable
    path.join(path.dirname(process.execPath), 'templates'),
    // Fallback to current working directory
    path.join('.', 'templates')
  ];
  
  for (const templatePath of possiblePaths) {
    if (existsSync(templatePath)) {
      return path.dirname(templatePath);
    }
  }
  
  // If no templates found, return a path that will cause clear errors
  console.error('Warning: Could not find templates directory');
  return process.cwd();
}

const PROJECT_ROOT = findTemplatesRoot();

// Vault template definitions
const VAULT_TEMPLATES: Record<string, any> = {
  minimal: {
    name: "Minimal Starter",
    description: "Clean start with basic folder structure",
    folders: ["notes", "daily", "attachments"],
    features: ["Simple daily notes", "Basic folder organization"],
  },
  para: {
    name: "PARA Method",
    description: "Projects, Areas, Resources, Archive - for productivity",
    folders: ["1-Projects", "2-Areas", "3-Resources", "4-Archive", "daily-notes", "templates", "attachments"],
    features: ["PARA organization", "Project tracking", "Daily notes", "Weekly reviews"],
  },
  pkm: {
    name: "Personal Knowledge Management",
    description: "Learning-focused with MOCs and progressive summarization",
    folders: ["MOCs", "Sources", "Ideas", "Projects", "daily-notes", "templates", "attachments"],
    features: ["Maps of Content", "Progressive summarization", "Daily notes", "Idea development"],
  },
  zettelkasten: {
    name: "Zettelkasten",
    description: "Atomic notes with unique IDs for academic research",
    folders: ["fleeting", "literature", "permanent", "index", "attachments"],
    features: ["Unique note IDs", "Atomic notes", "Strict linking", "Emergence patterns"],
  },
};

// Initialize MCP server
const server = new Server(
  {
    name: "obsidian-vault-bootstrap",
    version: "1.0.0",
  },
  {
    capabilities: {
      prompts: {},
      tools: {},
    },
  }
);


// Tool: Create vault
const createVaultTool: Tool = {
  const pluginsPath = path.join(obsidianPath, "plugins");
  const templatePluginsPath = path.join(PROJECT_ROOT, "templates/plugins");
  
  
  for (const pluginId of selectedPlugins) {
    const pluginPath = path.join(pluginsPath, pluginId);
    const templatePluginPath = path.join(templatePluginsPath, pluginId);
    
    // Create plugin directory
    await fs.mkdir(pluginPath, { recursive: true });
    
    // Check if we have a manifest for this plugin
    const manifestPath = path.join(templatePluginPath, "manifest.json");
    
    if (existsSync(manifestPath)) {
      try {
        // Copy manifest.json
        const manifest = await fs.readFile(manifestPath, 'utf-8');
        await fs.writeFile(path.join(pluginPath, "manifest.json"), manifest);
        
        // Copy other files if they exist (main.js, styles.css, data.json)
        const filesToCopy = ['main.js', 'styles.css', 'data.json'];
        for (const file of filesToCopy) {
          const sourcePath = path.join(templatePluginPath, file);
          if (existsSync(sourcePath)) {
            const content = await fs.readFile(sourcePath, 'utf-8');
            await fs.writeFile(path.join(pluginPath, file), content);
          }
        }
      } catch (error) {
        // Silently fall back to embedded manifest
      }
    } else {
      // Fallback: Create basic manifests for known plugins
      const fallbackManifests: Record<string, any> = {
        "templater-obsidian": {
          id: "templater-obsidian",
          name: "Templater",
          version: "2.14.0",
          description: "Create and use templates",
          minAppVersion: "1.5.0",
          author: "SilentVoid",
          authorUrl: "https://github.com/SilentVoid13",
          helpUrl: "https://silentvoid13.github.io/Templater/",
          isDesktopOnly: false
        },
        "dataview": {
          id: "dataview",
          name: "Dataview",
          version: "0.5.68",
          minAppVersion: "0.13.11",
          description: "Complex data views for the data-obsessed.",
          author: "Michael Brenan <blacksmithgu@gmail.com>",
          authorUrl: "https://github.com/blacksmithgu",
          helpUrl: "https://blacksmithgu.github.io/obsidian-dataview/",
          isDesktopOnly: false
        },
        "quickadd": {
          id: "quickadd",
          name: "QuickAdd",
          version: "1.14.0",
          minAppVersion: "0.13.19",
          description: "Quickly add content to your vault",
          author: "Christian B. B. Houmann",
          authorUrl: "https://github.com/chhoumann",
          helpUrl: "https://github.com/chhoumann/quickadd",
          isDesktopOnly: false
        },
        "readwise-official": {
          id: "readwise-official",
          name: "Readwise Official",
          version: "2.0.1",
          minAppVersion: "0.13.19",
          description: "Official Readwise plugin for syncing highlights",
          author: "Readwise",
          authorUrl: "https://readwise.io",
          helpUrl: "https://help.readwise.io",
          isDesktopOnly: false
        },
        "obsidian-tasks-plugin": {
          id: "obsidian-tasks-plugin",
          name: "Tasks",
          version: "7.14.0",
          minAppVersion: "1.1.1",
          description: "Task management for Obsidian",
          author: "Clare Macrae and others",
          authorUrl: "https://github.com/obsidian-tasks-group/obsidian-tasks",
          helpUrl: "https://publish.obsidian.md/tasks/",
          isDesktopOnly: false
        },
        "calendar": {
          id: "calendar",
          name: "Calendar",
          version: "1.5.10",
          minAppVersion: "0.9.11",
          description: "Calendar view of your daily notes",
          author: "Liam Cain",
          authorUrl: "https://github.com/liamcain",
          helpUrl: "https://github.com/liamcain/obsidian-calendar-plugin",
          isDesktopOnly: false
        }
      };
      
      if (fallbackManifests[pluginId]) {
        try {
          await fs.writeFile(
            path.join(pluginPath, "manifest.json"),
            JSON.stringify(fallbackManifests[pluginId], null, 2)
          );
        } catch (error) {
          // Silent fail
        }
      }
    }
  }
}

// Helper function to create Obsidian config
async function createObsidianConfig(vaultPath: string, template: string): Promise<string[]> {
  const obsidianPath = path.join(vaultPath, ".obsidian");
  await fs.mkdir(obsidianPath, { recursive: true });
  
  // Create plugins directory
  const pluginsPath = path.join(obsidianPath, "plugins");
  await fs.mkdir(pluginsPath, { recursive: true });
  
  // Load base configurations
  const appConfigPath = path.join(PROJECT_ROOT, "templates/configs/base-app.json");
  const pluginsConfigPath = path.join(PROJECT_ROOT, "templates/configs/base-plugins.json");
  
  // Create app.json (with community plugins enabled)
  let appConfig;
  try {
    appConfig = JSON.parse(await fs.readFile(appConfigPath, 'utf-8'));
  } catch (error) {
    console.error(`Failed to read app config from ${appConfigPath}:`, error);
    // Fallback to embedded config
    appConfig = {
      "attachmentFolderPath": "attachments",
      "alwaysUpdateLinks": true,
      "showLineNumber": true,
      "showFrontmatter": true,
      "defaultViewMode": "source",
      "readableLineLength": false,
      "promptDelete": false
    };
  }
  await fs.writeFile(
    path.join(obsidianPath, "app.json"),
    JSON.stringify(appConfig, null, 2)
  );
  
  // Create core-plugins.json
  const corePluginsPath = path.join(PROJECT_ROOT, "templates/configs/core-plugins.json");
  let corePlugins;
  try {
    if (existsSync(corePluginsPath)) {
      corePlugins = JSON.parse(await fs.readFile(corePluginsPath, 'utf-8'));
    } else {
      throw new Error('Core plugins config not found');
    }
  } catch (error) {
    // Fallback to embedded config
    corePlugins = {
      "file-explorer": true,
      "global-search": true,
      "switcher": true,
      "graph": true,
      "backlink": true,
      "canvas": true,
      "outgoing-link": true,
      "tag-pane": true,
      "properties": true,
      "page-preview": true,
      "daily-notes": true,
      "templates": true,
      "note-composer": true,
      "command-palette": true,
      "slash-command": false,
      "editor-status": true,
      "bookmarks": true,
      "markdown-importer": false,
      "zk-prefixer": false,
      "random-note": false,
      "outline": true,
      "word-count": true,
      "slides": false,
      "audio-recorder": false,
      "workspaces": false,
      "file-recovery": true,
      "publish": false,
      "sync": false
    };
  }
  await fs.writeFile(
    path.join(obsidianPath, "core-plugins.json"),
    JSON.stringify(corePlugins, null, 2)
  );
  
  // Create community-plugins.json
  // Note: The mere presence of this file with plugins disables restricted mode in Obsidian
  let pluginsConfig;
  try {
    pluginsConfig = JSON.parse(await fs.readFile(pluginsConfigPath, 'utf-8'));
  } catch (error) {
    console.error(`Failed to read plugins config from ${pluginsConfigPath}:`, error);
    // Fallback to embedded config
    pluginsConfig = {
      "minimal": ["templater-obsidian", "readwise-official"],
      "pkm": ["templater-obsidian", "dataview", "tasks-obsidian", "quickadd", "readwise-official"],
      "research": ["templater-obsidian", "citations", "pdf-plus", "readwise-official", "dataview"],
      "zettelkasten": ["templater-obsidian", "unique-note-id", "dataview", "readwise-official"],
      "project": ["templater-obsidian", "tasks-obsidian", "kanban", "quickadd"],
      "journaling": ["templater-obsidian", "calendar", "periodic-notes", "tracker"],
      "technical": ["templater-obsidian", "code-block-copy", "mermaid", "dataview"],
      "creative": ["templater-obsidian", "longform", "word-count", "writing-goals"],
      "gtd": ["templater-obsidian", "tasks-obsidian", "quickadd", "periodic-notes"],
      "business": ["templater-obsidian", "dataview", "kanban", "charts"],
      "content": ["templater-obsidian", "calendar", "tasks-obsidian", "tag-wrangler"],
      "learning": ["templater-obsidian", "spaced-repetition", "flashcards-obsidian", "tracker"]
    };
  }
  const selectedPlugins = pluginsConfig[template] || [];
  
  // Always include templater for template functionality
  if (!selectedPlugins.includes("templater-obsidian")) {
    selectedPlugins.push("templater-obsidian");
  }
  
  await fs.writeFile(
    path.join(obsidianPath, "community-plugins.json"),
    JSON.stringify(selectedPlugins, null, 2)
  );
  
  // Copy plugin manifests for auto-installation
  await copyPluginManifests(obsidianPath, selectedPlugins);
  
  // Create workspace.json
  const workspace = {
    main: {
      id: "main",
      type: "split",
      children: [{
        id: "leaf",
        type: "leaf",
        state: {
          type: "markdown",
          state: {
            file: "README.md",
            mode: "source",
            source: false
          }
        }
      }],
      direction: "vertical"
    },
    left: {
      id: "left",
      type: "split",
      children: [{
        id: "file-explorer",
        type: "leaf",
        state: {
          type: "file-explorer",
          state: { sortOrder: "alphabetical" }
        }
      }],
      direction: "horizontal",
      width: 300
    },
    active: "leaf"
  };
  
  await fs.writeFile(
    path.join(obsidianPath, "workspace.json"),
    JSON.stringify(workspace, null, 2)
  );
  
  // Create hotkeys configuration
  await createHotkeysConfig(obsidianPath, template);
  
  // Return the selected plugins for the success message
  return selectedPlugins;
}

// DEPRECATED: Plugin configuration functions
// Plugins must be installed through Obsidian's interface first
/*
// Helper function to configure Templater
async function configureTemplater(vaultPath: string, template: string) {
  const templaterPath = path.join(vaultPath, ".obsidian/plugins/templater-obsidian");
  await fs.mkdir(templaterPath, { recursive: true });
  
  // Copy Templater templates
  const templatesPath = path.join(vaultPath, "templates");
  await fs.mkdir(templatesPath, { recursive: true });
  
  // Copy template files based on vault type
  const sourceTemplatesPath = path.join(PROJECT_ROOT, "templates/templater");
  const templateFiles = ["daily-note.md", "meeting.md", "project.md"];
  
  for (const file of templateFiles) {
    const sourcePath = path.join(sourceTemplatesPath, file);
    try {
      if (existsSync(sourcePath)) {
        const content = await fs.readFile(sourcePath, 'utf-8');
        await fs.writeFile(path.join(templatesPath, file), content);
      } else {
        // Fallback to embedded templates
        let content = '';
        if (file === 'daily-note.md') {
          content = `# {{date:YYYY-MM-DD}} - {{date:dddd}}

## Tasks
- [ ] 

## Notes

## Journal
`;
        } else if (file === 'meeting.md') {
          content = `# Meeting: {{title}}
Date: {{date:YYYY-MM-DD HH:mm}}
Attendees: 

## Agenda
- 

## Notes

## Action Items
- [ ] 
`;
        } else if (file === 'project.md') {
          content = `# Project: {{title}}
Created: {{date:YYYY-MM-DD}}
Status: Active

## Goals
- 

## Tasks
- [ ] 

## Resources
- 
`;
        }
        if (content) {
          await fs.writeFile(path.join(templatesPath, file), content);
        }
      }
    } catch (error) {
      console.error(`Failed to copy template ${file}:`, error);
    }
  }
  
  // Create Templater configuration
  const templaterConfig = {
    "command_timeout": 5,
    "templates_folder": "templates",
    "templates_pairs": [
      ["", ""],
      ["daily-notes", "templates/daily-note.md"],
      ["meetings", "templates/meeting.md"],
      ["projects", "templates/project.md"]
    ],
    "trigger_on_file_creation": true,
    "auto_jump_to_cursor": true,
    "enable_system_commands": false,
    "shell_path": "",
    "user_scripts_folder": "templates/scripts",
    "enable_folder_templates": true,
    "folder_templates": [
      {
        "folder": "daily-notes",
        "template": "templates/daily-note.md"
      },
      {
        "folder": "meetings",
        "template": "templates/meeting.md"
      },
      {
        "folder": "projects",
        "template": "templates/project.md"
      }
    ],
    "syntax_highlighting": true,
    "startup_templates": [""]
  };
  
  await fs.writeFile(
    path.join(templaterPath, "data.json"),
    JSON.stringify(templaterConfig, null, 2)
  );
}

// Helper function to configure QuickAdd for ribbon buttons
async function configureQuickAdd(vaultPath: string, template: string) {
  const quickAddPath = path.join(vaultPath, ".obsidian/plugins/quickadd");
  await fs.mkdir(quickAddPath, { recursive: true });
  
  // Create QuickAdd macros for common actions
  const quickAddConfig = {
    "choices": [
      {
        "id": "daily-note",
        "name": "📅 Daily Note",
        "type": "Template",
        "command": true,
        "templatePath": "templates/daily-note.md",
        "folder": "daily-notes",
        "appendLink": false,
        "openFile": true
      },
      {
        "id": "new-meeting",
        "name": "👥 New Meeting",
        "type": "Template",
        "command": true,
        "templatePath": "templates/meeting.md",
        "folder": "meetings",
        "appendLink": false,
        "openFile": true
      },
      {
        "id": "new-project",
        "name": "🚀 New Project",
        "type": "Template",
        "command": true,
        "templatePath": "templates/project.md",
        "folder": "projects",
        "appendLink": false,
        "openFile": true
      },
      {
        "id": "quick-capture",
        "name": "💡 Quick Capture",
        "type": "Capture",
        "command": true,
        "appendLink": false,
        "captureTo": "inbox/quick-capture.md",
        "captureToActiveFile": false,
        "createFileIfItDoesntExist": true,
        "format": "- {{VALUE}}\n",
        "insertAfter": "## Captures",
        "openFile": false,
        "prepend": false
      }
    ],
    "macros": [],
    "inputPrompt": "single-line",
    "devMode": false,
    "version": "0.14.0"
  };
  
  await fs.writeFile(
    path.join(quickAddPath, "data.json"),
    JSON.stringify(quickAddConfig, null, 2)
  );
}

// Helper function to configure Readwise
async function configureReadwise(vaultPath: string, template: string) {
  const readwisePath = path.join(vaultPath, ".obsidian/plugins/readwise-official");
  await fs.mkdir(readwisePath, { recursive: true });
  
  // Create Readwise folders
  const readwiseFolders = [
    "Readwise",
    "Readwise/Books", 
    "Readwise/Articles",
    "Readwise/Podcasts",
    "Readwise/Tweets",
    "Readwise/Supplementals"
  ];
  
  for (const folder of readwiseFolders) {
    await fs.mkdir(path.join(vaultPath, folder), { recursive: true });
  }
  
  // Load and customize Readwise config based on template
  const configPath = path.join(PROJECT_ROOT, "templates/readwise/readwise-config.json");
  let readwiseConfig;
  try {
    readwiseConfig = JSON.parse(await fs.readFile(configPath, 'utf-8'));
  } catch (error) {
    console.error(`Failed to read Readwise config from ${configPath}:`, error);
    // Fallback to embedded config
    readwiseConfig = {
      "token": "",
      "readwiseDir": "Readwise",
      "frequency": "60",
      "triggerOnLoad": true,
      "isSyncing": false,
      "lastSyncFailed": false,
      "lastSavedStatusID": 0,
      "currentSyncStatusID": 0,
      "refreshBooks": true,
      "booksToRefresh": [],
      "booksIDsMap": {},
      "articleIDsMap": {},
      "newFormatPathBooks": "Readwise/Books/{{title}}.md",
      "newFormatPathArticles": "Readwise/Articles/{{title}}.md"
    };
  }
  
  // Customize paths based on template type
  if (template === "zettelkasten") {
    readwiseConfig.newFormatPathBooks = "literature/books/{{title}}.md";
    readwiseConfig.newFormatPathArticles = "literature/articles/{{title}}.md";
  } else if (template === "research") {
    readwiseConfig.newFormatPathBooks = "literature-notes/books/{{title}}.md";
    readwiseConfig.newFormatPathArticles = "literature-notes/articles/{{title}}.md";
  } else if (template === "pkm") {
    readwiseConfig.newFormatPathBooks = "3-Resources/Books/{{title}}.md";
    readwiseConfig.newFormatPathArticles = "3-Resources/Articles/{{title}}.md";
  }
  
  await fs.writeFile(
    path.join(readwisePath, "data.json"),
    JSON.stringify(readwiseConfig, null, 2)
  );
  
  // Copy Readwise templates
  const readwiseTemplates = [
    "book-template.md",
    "article-template.md",
    "podcast-template.md"
  ];
  
  const templatesPath = path.join(vaultPath, "templates/readwise");
  await fs.mkdir(templatesPath, { recursive: true });
  
  for (const templateFile of readwiseTemplates) {
    const sourcePath = path.join(PROJECT_ROOT, "templates/readwise", templateFile);
    try {
      if (existsSync(sourcePath)) {
        const content = await fs.readFile(sourcePath, 'utf-8');
        await fs.writeFile(path.join(templatesPath, templateFile), content);
      } else {
        // Fallback to embedded templates
        let content = '';
        if (templateFile === 'book-template.md') {
          content = `# {{title}}

## Metadata
- Author: {{author}}
- Category: {{category}}

## Highlights
{{highlights}}

## Summary
{{summary}}`;
        } else if (templateFile === 'article-template.md') {
          content = `# {{title}}

## Metadata
- Author: {{author}}
- URL: {{url}}

## Highlights
{{highlights}}

## Summary
{{summary}}`;
        } else if (templateFile === 'podcast-template.md') {
          content = `# {{title}}

## Metadata
- Show: {{show}}
- Episode: {{episode}}

## Notes
{{highlights}}

## Key Takeaways
{{summary}}`;
        }
        if (content) {
          await fs.writeFile(path.join(templatesPath, templateFile), content);
        }
      }
    } catch (error) {
      console.error(`Failed to copy Readwise template ${templateFile}:`, error);
    }
  }
  
  // Create Readwise README
  const readwiseReadme = `# Readwise Integration

## Setup Instructions

1. Get your Readwise API token from: https://readwise.io/access_token
2. Open Obsidian Settings → Community Plugins → Readwise Official
3. Enter your API token
4. Click "Initiate Sync" to import your highlights

## Folder Structure

- **Readwise/Books/** - Book highlights and notes
- **Readwise/Articles/** - Article highlights
- **Readwise/Podcasts/** - Podcast notes
- **Readwise/Tweets/** - Saved tweets
- **Readwise/Supplementals/** - Additional notes

## Features

- Auto-sync every 60 minutes
- Custom templates for each content type
- Automatic tagging and categorization
- Metadata preservation
- Cross-linking with your other notes

## Templates

Custom templates are located in \`templates/readwise/\`:
- Book Template: Full book notes with highlights
- Article Template: Web articles and blog posts
- Podcast Template: Episode notes and takeaways

## Tips

- Use tags like #readwise/book or #readwise/article to filter
- Create MOCs (Maps of Content) for your reading lists
- Link book notes to project notes for research
- Use Dataview to create reading dashboards
`;
  
  await fs.writeFile(
    path.join(vaultPath, "Readwise/README.md"),
    readwiseReadme
  );
}
*/

// Helper function to create hotkeys configuration
async function createHotkeysConfig(obsidianPath: string, template: string) {
  const hotkeys = {
    "app:toggle-left-sidebar": [
      {
        "modifiers": ["Mod", "Shift"],
        "key": "L"
      }
    ],
    "app:toggle-right-sidebar": [
      {
        "modifiers": ["Mod", "Shift"],
        "key": "R"
      }
    ],
    "templater-obsidian:insert-templater": [
      {
        "modifiers": ["Mod"],
        "key": "T"
      }
    ],
    "templater-obsidian:create-new-note-from-template": [
      {
        "modifiers": ["Mod", "Alt"],
        "key": "N"
      }
    ],
    "quickadd:runQuickAdd": [
      {
        "modifiers": ["Mod"],
        "key": "Q"
      }
    ],
    "daily-notes:goto-daily-note": [
      {
        "modifiers": ["Mod", "Shift"],
        "key": "D"
      }
    ]
  };
  
  await fs.writeFile(
    path.join(obsidianPath, "hotkeys.json"),
    JSON.stringify(hotkeys, null, 2)
  );
}

// Tool: Create vault
const createVaultTool: Tool = {
  name: "create_vault",
  description: "Create a new Obsidian vault with selected template",
  inputSchema: {
    type: "object",
    properties: {
      path: {
        type: "string",
        description: "Path where the vault should be created (optional, defaults to ~/Documents/Obsidian)",
      },
      template: {
        type: "string",
        enum: Object.keys(VAULT_TEMPLATES),
        description: "Template type to use",
      },
      name: {
        type: "string",
        description: "Name of the vault",
      },
    },
    required: ["template", "name"],
  },
};

// Tool: List templates
const listTemplatesTool: Tool = {
  name: "list_templates",
  description: "List all available vault templates",
  inputSchema: {
    type: "object",
    properties: {},
  },
};

// Register tools
server.setRequestHandler(ListToolsRequestSchema, async () => ({
  tools: [createVaultTool, listTemplatesTool],
}));

// Handle tool calls
server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const { name, arguments: args } = request.params;
  
  switch (name) {
    case "create_vault": {
      const { path: vaultPath, template, name: vaultName } = args as any;
      
      // Expand and validate the path
      let expandedPath = vaultPath;
      
      // If no path provided, use default
      if (!expandedPath || expandedPath === '') {
        expandedPath = path.join(os.homedir(), 'Documents', 'Obsidian');
      }
      
      // Handle common path shortcuts
      if (expandedPath.startsWith('~')) {
        expandedPath = expandedPath.replace(/^~/, os.homedir());
      }
      
      // Handle relative paths like "Documents" or "Desktop"
      if (!expandedPath.startsWith('/') && !expandedPath.startsWith('C:') && !expandedPath.includes(':')) {
        // It's a relative path, prepend home directory
        expandedPath = path.join(os.homedir(), expandedPath);
      }
      
      // If path starts with /Users/Documents without username, add current user
      if (expandedPath === '/Users/Documents' || expandedPath.startsWith('/Users/Documents/')) {
        const homeDir = os.homedir();
        expandedPath = expandedPath.replace('/Users/Documents', `${homeDir}/Documents`);
      }
      
      // Default to Documents folder if path is invalid
      if (expandedPath === '/Users' || expandedPath === '/' || expandedPath === 'C:\\') {
        expandedPath = path.join(os.homedir(), 'Documents', 'Obsidian');
      }
      
      // Ensure parent directory exists
      try {
        await fs.mkdir(expandedPath, { recursive: true });
      } catch (error) {
        console.error(`Failed to create parent directory: ${expandedPath}`);
      }
      
      const fullPath = path.join(expandedPath, vaultName);
      
      // Check if directory already exists
      if (existsSync(fullPath)) {
        return {
          content: [
            {
              type: "text",
              text: `Error: Directory ${fullPath} already exists`,
            },
          ],
        };
      }
      
      try {
        // Get template config
        const templateConfig = VAULT_TEMPLATES[template as keyof typeof VAULT_TEMPLATES];
        if (!templateConfig) {
          return {
            content: [
              {
                type: "text",
                text: `Error: Unknown template "${template}"`,
              },
            ],
          };
        }

        // Create vault directory
        await fs.mkdir(fullPath, { recursive: true });

        // Create folder structure
        for (const folder of templateConfig.folders) {
          await fs.mkdir(path.join(fullPath, folder), { recursive: true });
        }

        // Create basic .obsidian folder
        await fs.mkdir(path.join(fullPath, '.obsidian'), { recursive: true });
        
        return {
          content: [
            {
              type: "text",
              text: `✅ **Vault Created Successfully!**

📁 **Location:** ${fullPath}
🎨 **Template:** ${templateConfig.name}

## What I've Set Up For You:

### 📂 Folder Structure
${templateConfig.folders.map((f: string) => `- ${f}/`).join('\n')}

## 🚀 Quick Start Guide

### Step 1: Open Your Vault
1. Open Obsidian
2. Click "Open folder as vault"
3. Select: ${fullPath}

### Step 2: Enable Community Plugins
1. When prompted about restricted mode, click "Turn off restricted mode"
2. Plugins will auto-download and install
3. You may need to reload Obsidian once for all plugins to activate

### Step 3: Your Daily Workflow
${template === 'pkm' ? 
`1. **Morning**: Create daily note (Cmd+Shift+D)
2. **During day**: Quick capture ideas (Cmd+Q)
3. **Reading**: Highlights sync via Readwise
4. **Evening**: Process inbox, create permanent notes
5. **Weekly**: Review and organize` :
template === 'research' ?
`1. **New source**: Create literature note
2. **While reading**: Highlight in Readwise
3. **After reading**: Process into permanent notes
4. **Writing**: Link notes in your drafts
5. **Weekly**: Update bibliography` :
`1. Start with daily note
2. Capture ideas as they come
3. Review and organize weekly`}

### Step 4: First Actions
- [ ] Create your first daily note
- [ ] Set up Readwise integration
- [ ] Explore the templates folder
- [ ] Customize your first template
- [ ] Create a test note with Cmd+T

## 💡 Pro Tips
- Start simple, add complexity over time
- Use templates for everything repetitive
- Let Readwise handle your reading highlights
- Review and refactor regularly

Your vault is ready! Open it in Obsidian to start building your knowledge system. 🎉`,
            },
          ],
        };
      } catch (error) {
        return {
          content: [
            {
              type: "text",
              text: `Error creating vault: ${error}`,
            },
          ],
        };
      }
    }
    
    case "list_templates": {
      const templateList = Object.entries(VAULT_TEMPLATES)
        .map(([key, template]) => {
          return `**${template.name}** (${key})\n${template.description}\nFeatures: ${template.features.join(", ")}`;
        })
        .join("\n\n");

      return {
        content: [
          {
            type: "text",
            text: `Available Vault Templates:\n\n${templateList}`,
          },
        ],
      };
    }

    default:
      return {
        content: [
          {
            type: "text",
            text: `Unknown tool: ${name}`,
          },
        ],
      };
  }
});

// Register prompts
server.setRequestHandler(ListPromptsRequestSchema, async () => ({
  prompts: [
    {
      name: "bootstrap_vault",
      description: "Interactive Obsidian vault creation wizard",
      arguments: [
        {
          name: "location",
          description: "Where to create the vault (optional)",
          required: false,
        },
      ],
    },
  ],
}));

// Handle prompt requests
server.setRequestHandler(GetPromptRequestSchema, async (request) => {
  const { name, arguments: args } = request.params;

  if (name === "bootstrap_vault") {
    // Get the actual user's Documents path
    const defaultLocation = path.join(os.homedir(), 'Documents', 'Obsidian');
    const location = args?.location || defaultLocation;

    const messages: PromptMessage[] = [
      {
        role: "assistant",
        content: {
          type: "text",
          text: `# 🎯 Obsidian Vault Bootstrap & Migration Assistant

I'll help you create a new Obsidian vault or migrate an existing configuration.

## Option 1: Fresh Start with Templates 📚

**Quick Presets:**
- **minimal** - Clean start with basic folders
- **para** - Projects, Areas, Resources, Archive method
- **pkm** - Personal Knowledge Management with MOCs
- **zettelkasten** - Academic note-taking with atomic notes

**Example:** "Create a PKM vault called Second-Brain"

## Option 2: Migrate from GitHub Repo 🔄

**Share a GitHub URL with a .obsidian folder and I'll:**
1. Clone and analyze the configuration
2. Explain the key hotkeys and workflows
3. Guide you through recreating the setup
4. Help you understand the system

**Example:** "Help me migrate from https://github.com/kepano/obsidian-minimal"

---

## For AI Agent: Migration Instructions

When user provides a GitHub URL:

### 1. Clone and Analyze
\`\`\`bash
# Clone the repo to temp directory
git clone --depth 1 [REPO_URL] /tmp/obsidian-analysis

# Check for .obsidian folder
ls -la /tmp/obsidian-analysis/.obsidian/

# List plugins
ls /tmp/obsidian-analysis/.obsidian/plugins/

# Check key config files
cat /tmp/obsidian-analysis/.obsidian/app.json
cat /tmp/obsidian-analysis/.obsidian/hotkeys.json
cat /tmp/obsidian-analysis/.obsidian/community-plugins.json
\`\`\`

### 2. Create New Vault
\`\`\`bash
# Use create_vault tool for base structure
# Then manually copy configs

# Copy .obsidian folder (excluding plugins data)
cp -r /tmp/obsidian-analysis/.obsidian [NEW_VAULT_PATH]/
rm -rf [NEW_VAULT_PATH]/.obsidian/plugins/*/

# Just keep plugin manifests
find /tmp/obsidian-analysis/.obsidian/plugins -name "manifest.json" -exec sh -c 'mkdir -p [NEW_VAULT_PATH]/.obsidian/plugins/$(basename $(dirname {})) && cp {} [NEW_VAULT_PATH]/.obsidian/plugins/$(basename $(dirname {}))/' \\;
\`\`\`

### 3. Explain Key Features
- Parse hotkeys.json and explain important shortcuts
- List community plugins and their purposes
- Identify workflow patterns (daily notes, zettelkasten, etc.)
- Note any custom CSS or themes

### 4. Guide Setup
- List plugins to install from Obsidian Community Plugins
- Explain folder structure and organization system
- Highlight important settings to configure
- Suggest starting points for the user

Remember: Don't overcomplicate! Use basic bash commands and explain what you're doing.`,
        },
      },
    ];
    
    return { messages };
  }
  
  return { messages: [] };
});

// Start the server
async function main() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.error("Obsidian Vault Bootstrap MCP Server running on stdio");
}

main().catch((error) => {
  console.error("Fatal error:", error);
  process.exit(1);
});